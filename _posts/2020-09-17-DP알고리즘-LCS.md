---
date: 2020-09-17 21:00:00
layout: post
title: LCS-최장공통부분수열-DP-다이나믹프로그래밍
subtitle: 알고리즘 좀 꾸준히 해라 대훈아 제발
description: 백준-9251-LCS
image: /assets/img/work/백준.jpg
optimized_image: /assets/img/work/알고리즘배경2.jpg
category: code
tags:
  - Eclipse
  - Java
  - BaekJooN
  - Algorithm
  - DP
  - Lcs
author: daehun
---

## 알고리즘 좀 매일 하자 매일 대훈아

카카오 블라인드 채용 알고리즘 문제들을 풀면서

문자열 문제들이 진짜 많이 나왔다.

그리고 효율성 또한 많이 따지는 문제들이 나와서

DP알고리즘은 필수라고 생각해서 DP 문제들을 풀어보려고 한다.

## DP 동적 계획법 Dynamic programming

학과 컴퓨터 과학, 그리고 경제학에서 동적 계획법(動的計劃法, dynamic programming)이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다. 이것은 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간 내에 풀 때 사용한다. - 위키백과

### 원리는 간단하다. 코드말고

어떠한 주어진 큰 문제가 있다면 이 문제를 여러개의 하위 문제로 나누어 푼다.

그리고 하위 문제들을 해결하고 계산한뒤 그 값을 저장한다. 

방금 저장했던 하위 문제들이 또 나오게 되면 저장해놓은 값을 사용한다.

아주 큰 문제를 해결할때 유용한 방법.

최단경로문제, 행렬의 제곱, 최적화 문제에 자주 등장한다.

## 가장 대표적인 예시 피보나치수열

피보나치 수열이라고 

1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987

이전 항 2개를 더하면 다음 항 나오는 수열

만약 fib(5)를 구하고 싶다

그럼 fib(4)+fib(3) 를 구해야하고 이것은 

(fib(3) + fib(2)) + (fib(2) + fib(1)) 를 의미하며 이것은 또

((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))

를 의미한다.

결국 fib(5)는 

(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))

이걸 의미하는데 이런식으로 계속해서 재귀함수를 호출해서 시간이 아주 많이 걸린다.

이걸 해결하는 것이 DP

```java
int dp[] =  new int[5];

//이런식으로 저장할 DP배열을 만든다음

static int fibona(n){
	if(n==0)return 0;
	if(n==1)return 1;

	//이미 들린적이 있다면 저장했던값 바로 리턴해주기
	if(dp[n] != -1)return dp[n];

	//한번도 저장 해놓은적 없는 하위문제라면 저장하고 리턴
	dp[n]= fibona(n-2) + fibona(n-1);
	return dp[n];
}
```
이렇게 계산값을 저장해놓으면 중복 계산이 줄어든다.

아무튼 백준 문제들을 풀어보자 

## 백준 9251 LCS
문제출처 - https://www.acmicpc.net/problem/9251

### 문제
LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

### 입력
첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

### 출력
첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.

### 예시입력
ACAYKP
CAPCAK
### 예시출력
4

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class LCS {

	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		String input1 = br.readLine();
		String input2 = br.readLine();
		
		int dp[][] = new int [input1.length()+1][input2.length()+1];
		
		for(int i = 1 ; i  < input1.length()+1;i++) {
			char input1Char = input1.charAt(i-1);
			for(int j = 1 ; j< input2.length()+1; j++) {
				char input2Char = input2.charAt(j-1);
				if(input1Char==input2Char) {
					dp[i][j] = dp[i-1][j-1]+1;
				}else {
					dp[i][j]=Math.max(dp[i-1][j], dp[i][j-1]);
				}
			}
		}
		System.out.println(dp[input1.length()][input2.length()]);
	}

}

```

엄청 어려워 보였던 문제가 몇 줄만에 뚝딱 해결됬다..

이와 같은 방식은 유튜브에 외국인이 설명해준 방식으로 문제를 풀었는데

https://youtu.be/P-mMvhfJhu8 

이걸 참고하도록 하자.

