---
date: 2018-07-20 12:26:40
layout: post
title: 김대훈 첫번째 테스트 글
subtitle: 글 올리기전 첫번째 테스트.
description: Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
image: https://res.cloudinary.com/dm7h7e8xj/image/upload/v1559820489/js-code_n83m7a.jpg
optimized_image: https://res.cloudinary.com/dm7h7e8xj/image/upload/c_scale,w_380/v1559820489/js-code_n83m7a.jpg
category: code
tags:
  - Eclipse
  - Java
  - BOJ
author: thiagorossener
---

백준 문제 1504 특정한 최단경로 문제 푼것을 첫글로 시작.

## 특정한 최단경로 백준 1504

방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.

세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.

# 입력

첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1)

# 출력

첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.

```js
// Example can be run directly in your JavaScript console

// Create a function that takes two arguments and returns the sum of those arguments
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {
static StringTokenizer st;
static int N,E,map[][],cnt[][][],result,ridge1,ridge2;

	public static void main(String[] args) throws IOException{
		BufferedReader br  = new BufferedReader(new InputStreamReader(System.in));
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		E = Integer.parseInt(st.nextToken());
		map = new int[N+1][N+1];
		cnt = new int[N+1][2][2];
		result = 987654321;
		for(int i = 1 ; i <=N ;i++) {
			for(int j=1; j<=N; j++) {

				if(i==j)map[i][j]=0;

				else {
					map[i][j]=987654321;
					map[j][i]=987654321;
				}
			}
			cnt[i][0][0]=987654321;
			cnt[i][1][0]=987654321;
			cnt[i][0][1]=987654321;
			cnt[i][1][1]=987654321;
		}
		for(int e = 0 ; e<E;e++) {
			st = new StringTokenizer(br.readLine());
			int x = Integer.parseInt(st.nextToken());
			int y = Integer.parseInt(st.nextToken());
			int z = Integer.parseInt(st.nextToken());
			map[x][y]=z;
			map[y][x]=z;
		}
		st = new StringTokenizer(br.readLine());
		ridge1 = Integer.parseInt(st.nextToken());
		ridge2 = Integer.parseInt(st.nextToken());

//		boolean visit[] = new boolean [2];
		if(ridge1==1) {
			cnt[1][1][0]=0;
			bfs(new Node(1,1,0,true,false));
		}
		else {
		cnt[1][0][0]=0;
		bfs(new Node(1,1,0,false,false));
		}
		if(result==987654321)System.out.println("-1");
		else {
			System.out.println(result);
			}
	}
	private static void bfs(Node node) {
		PriorityQueue<Node> q1 = new PriorityQueue<Node>();
		q1.add(node);
		while(!q1.isEmpty()) {
			Node temp = q1.poll();
			int x = temp.x;
			int y = temp.y;
			int count = temp.cnt;

		//	System.out.println(count+"몇번옴");

			if(y==N) {

				if(temp.ridgeFlag1&&temp.ridgeFlag2) {
		//			System.out.println(result+"들어온 리절트 "+count+"들어온 카운트" + x + ", " + y);
					result = Math.min(result, count);
				}

			}

			for(int i = 1 ; i<=N; i++) {
				boolean ridgeFlag1 = temp.ridgeFlag1;
				boolean ridgeFlag2 = temp.ridgeFlag2;

				if(map[y][i]==0||map[y][i]==987654321) {
					continue;
				}
				if(i==ridge1)ridgeFlag1=true;
				if(i==ridge2)ridgeFlag2=true;
				if(cnt[i][ridgeFlag1 ? 1 : 0][ridgeFlag2 ? 1 : 0]<=count+map[y][i])continue;
				cnt[i][ridgeFlag1 ? 1 : 0][ridgeFlag2 ? 1 : 0]=count+map[y][i];
				q1.add(new Node(y,i,count+map[y][i],ridgeFlag1,ridgeFlag2));
			}


		}

	}
	static class Node implements Comparable<Node>{
		int x;
		int y;
		int cnt;
		boolean ridgeFlag1;
		boolean ridgeFlag2;
		Node(int x, int y, int cnt,boolean ridgeFlag1, boolean ridgeFlag2){
			this.x=x;
			this.y=y;
			this.cnt = cnt;
			this.ridgeFlag1 = ridgeFlag1;
			this.ridgeFlag2 = ridgeFlag2;
		}
		@Override
		public int compareTo(Node o) {
			return o.cnt > this.cnt? -1:1;
		}
	}

}


// Call the function

// > 8
```

첫글이다. 포스트 폴더에 md 방식으로 글을 올리면 써지는거 같다.
