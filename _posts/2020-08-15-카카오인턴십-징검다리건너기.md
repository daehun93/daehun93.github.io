---
date: 2020-08-15 21:00:00
layout: post
title: 이진탐색 알고리즘 카카오 징검다리 건너기
subtitle: 알고리즘 좀 꾸준히 해라 대훈아 제발
description: 카카오 겨울 인턴십 2019 문제 레벨3
image: /assets/img/work/알고1.jpg
optimized_image: /assets/img/work/알고2.jpg
category: code
tags:
  - Eclipse
  - Java
  - KaKao
  - Algorithm
  - programmers
  - 이진탐색
author: daehun
---

## 알고리즘 좀 매일 하자 매일 대훈아

배경 이미지는 항상 알고를 풀 때 내 멘탈 상태

프로그래머스 카카오 겨울 인턴십 2019 징검다리 건너기

level3

문제를 읽고 어제 level4보다 더 머리에 안 떠올랐다.

2억의 원소들을 생각하니 내 머리로 푼다면

분명히 효율점수에서 틀렸습니다.를 도르마무를 통해서 봤고

결국 이진탐색이라는 힌트를 얻고 나서 성공..

## 카카오 인턴십 문제 징검다리건너기
문제출처 - <https://programmers.co.kr/learn/courses/30/lessons/64062>

### 문제

문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

카카오 초등학교의 니니즈 친구들이 라이언 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. 라이언 선생님은 니니즈 친구들이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.
니니즈 친구들은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.
니니즈 친구들은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

[제한사항]
징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
stones 배열의 크기는 1 이상 200,000 이하입니다.
stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
k는 1 이상 stones의 길이 이하인 자연수입니다.

[입력]

stones
[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]

k
3

[출력]
result
3

## 이진탐색 간략 설명

먼저 이진탐색을 아주 간단하게 그림없이 말로만 설명한다면

스무고개를 예를 들자

1~40까지 숫자중에 내가 생각하는 숫자를 맞추어 보라고하고

정답을 35로 가정하고 맞춰보라고 한다.

그럼 김대훈은 1,2,3,4,5,6,7~~ 이렇게 정답을 외치면

35를 찾으려면 35번 불러야한다.

이걸 이진탐색으로 찾는다면

먼저 "20보다 위입니까?"(yes)

20~40 중 "30보다 위입니까?"(yes)

30~40 중 "35보다 크거나 같고 40 보다 작습니까?"(yes)

그럼 35,36,37,38,39,40 6개 그냥 답으로 외쳐도

앞에 서른 다섯번 불러서 찾는거 보다 빠르다.

이렇게 반 반 쪼개서 찾는게 이진탐색

### 이 문제에서 2진탐색을 적용해서 풀면

최소 1명 ~ 최대 2억 중에 정답을 찾는 스무고개를 생각하면 된다.

"1억보다 큽니까?"(No)

"5천보다 큽니까?"(Yes)

이런식으로 쪼개서 징검다리를 건널 수 있는 사람 수를 찾으면 끝

어떻게 이런 생각을 했을까.. 문제를 봤을때 나는 몰랐는데

진짜 갈길이 멀고도 멀다.

일단 내가 제출한 정답코드

```java
package programmers;

public class 징검다리 {

	public static void main(String[] args) {
		int [] stones = {2, 4, 5, 3, 2, 1, 4, 2, 5, 1};
		int k = 3;
		solution(stones,k);
	}

	public static int solution(int[] stones, int k) {
		int min = 1;
		int max = 200000000;
		int answer = 0;
		
		while(min < max-1) {	//이부분우씨
			int mid = (min+max)/2;	//중간값 만큼 건널 수 있나 없나
			boolean flag = true; //이숫자는 못 건넌다 가능/불가능 나누기

			int zero = 0 ; //못건너는 돌이 몇개 되는가 이게 k보다 커지면 못건넘

			//System.out.println(mid);
			for(int i = 0 ; i < stones.length; i++) {
				if(stones[i]<mid) {
					zero++;
				}else {
					zero = 0;
				}
				if(zero>=k) {
					flag = false;
					break;
				}
			}
			if(flag) {	//mid숫자만큼 건널수 있다.그럼 더 많은 사람이 가야함 최소값을 올려줌
				min = mid;
			}else {//못건넌다	그럼 최대값을 낮춰야함
				max = mid;
			}
		}
		answer = min;
		System.out.println(answer);
		return answer;
	}
}
```

문제를 풀때 멍청하게 실수한 부분이 있었다.

```java

while(min < max-1) {	//이부분우씨
			
			if(flag) {	//mid숫자만큼 건널수 있다.그럼 더 많은 사람이 가야함 최소값을 올려줌
				min = mid;
			}else {//못건넌다	그럼 최대값을 낮춰야함
				max = mid;
			}
		}
```

이 while문에 (min < max-1) 이 부분이

while (min <=max) 이렇게 해버려서 계속 무한루프에 빠진것..

min과 max 둘다 중간값이 되버리면 계속 도는데

max-1 로 분명한 구별을 줘야한다는 것.
